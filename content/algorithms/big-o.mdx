---
title: Big O Notation
metaTitle: 'Big O Notation | Algorithms | Interview Prep | Tiffany Lea'
metaDescription: 'Big O Notation'
---

# What is Big O Notation?

Simplified analysis of an algorithm's efficiency in worst case scenario (very large input size).

# Formula

```
O(n)
```

- O: represents the function or algorithm that is being evaluated... "Big O"
- n: represents the number of elements/input

# Order of Complexity

|     | Big O            | Description                         | What that means                                                                             |
| --- | ---------------- | ----------------------------------- | ------------------------------------------------------------------------------------------- |
| ğŸ¤©  | O(1)             | Static                              | You know exactly how long it will take to run the function everytime (large or small input) |
| ğŸ˜  | O(log n)         | "divide and conquer", binary search | Break results into 2, eliminate 50% that doesn't contain item                               |
| ğŸ™‚  | O(n)             | Directly and linearly linked with N | How long it takes to run is directly based on how big N is (for loops)                      |
| ğŸ˜’  | O(n log n)       | Merge search, like deck of cards    | ...                                                                                         |
| ğŸ˜¬  | O(n<sup>2</sup>) | Checking list and grocery cart      | Doing something against 2+ variable length inputs makes it exponential                      |
| ğŸ˜³  | O(infinity)      | Flipping a coin                     | There is a chance the coin may never turn up heads and would have to go on forever          |

# General Rules

1. Certain terms **dominate** others, drop lower order terms

<CodeWithHtml>
  O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n<sup>2</sup>) &lt; O(2<sup>n</sup>) &lt;
  O(n!)
</CodeWithHtml>

2. Ignore constants

```
5n -> n -> O(n)
```

## Examples

<CodeWithHtml>
  T(n) = 17n<sup>4</sup> + 3n<sup>3</sup> + 4n + 8
</CodeWithHtml>
1. O(n<sup>4</sup>) dominates over O(n<sup>3</sup>) O(n) O(1)
<CodeWithHtml>
  T(n) = 17n<sup>4</sup>
</CodeWithHtml>
2. Ignore constants
<CodeWithHtml>
  T(n) = O(n<sup>4</sup>)
</CodeWithHtml>

# Constant Runtime | O(1) | O of 1

As the input size increases, the number of operations that we perform never changes.

```javascript
// Big O Notation: O(1)
function log(array) {
  console.log(array[0]);
  console.log(array[1]);
}
```

# Linear Runtime | O(n) | O of n

- The runtime is proportional to the input size.
- As the input increases so does the runtime.
- Each time we add to input we add to how many times we need to execute the function.

```javascript
// Big O Notation: O(n)
function logAll(array) {
  for (var i = 0; i < array.length; i++) {
    console.log(array[i]);
  }
}
```

# Exponential Runtime | O(n^2) | O of n squared

- Runtime grows exponentially based on input size.
- Iterates through the entire array and for every element it goes through the entire array again.

```javascript
// Big O Notation: O(n^2)
function addAndLog(array) {
  for (var i = 0; i < array.length; i++) {
    for (var j = o; j < array.length; j++) {
      console.log(array[i] + array[j]);
    }
  }
}
```

# Logarithmic Runtime | O(log n) | O of log n

With every operation performed we cut the input in half.

```javascript
// Big O Notation: O(log n)
function binarySearch(array, key) {
  var low = 0;
  var high = array.length - 1;
  var mid;
  var element;

  while (low <= high) {
    mid = Math.floor((low + high) / 2, 10);
    element = array[mid];
    if (element < key) {
      low = mid + 1;
    } else if (element > key) {
      high = mid - 1;
    } else {
      return mid;
    }
    return -1;
  }
}
```
